# Java并发

> 书籍推荐：
>
> 《Java并发编程的艺术》
>
> 《Java并发编程实战》
>
> 《Java并发编程实践》

## 术语&概念

1. 上下文切换

   ​        即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配***CPU时间片***来实现这个机制。时间片是CPU分配给每个线程的时间，因为时间非常短，所以CPU通过不停地切换线程执行。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务事时，可以再加载这个任务的状态。所以***任务从保存到再加载的过程就是一次上下文切换***。

2. 多线程的性能消耗

   线程有创建和上下文切换的开销。

   减少上下文的方法有无锁并发编程、CAS算法、使用最小线程和使用协程。

3. 进程&&线程&&协程

4. 并发编程需要处理两个关键问题：

   - 线程之间通信

     通信是指线程之间以何种机制来交换信息。

     ***线程之间的通信机制有两种***：

      - 共享内存
      - 消息传递

   - 线程之间同步

     ***同步是指程序中用于控制不同线程间操作发生相对顺序的机制***。

5. 指令的重排序

   重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。

   简单的说，就是会改变程序指令的执行顺序。

   ***重排序可能会导致多线程程序出现内存可见性问题***。



## Java中一个关键字
1. volatile

  （1）volatile简介：

  ​       volatile是轻量级的synchronize，它在多处理器开发中保证了共享变量的“可见性”。***可见性是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值***。如果volatile变量修饰符使用恰当的话，它比synchronize的使用和执行成本更低，因为***它不会引起线程上下文的切换和调度***。

  （2）涉及角色：

  ​	缓存、内存

  （3）volatile原理：

  ​	Lock前缀执行在多核处理器下会引发两件事情。

   - 将当前处理器缓存行的数据回写到系统内存。
   - 这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效。为了提高处理速度，处理器不直接和内存进行通信，而是先将***系统内存***的数据读到***内部缓存（L1,L2或其他）***后在进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条***Lock前缀的指令***，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现***缓存一致性协议***，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

  （4）volatile的两条实现原则

  - Lock前缀指令会引起处理器缓存回写到内存。
  - 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。

  （5）***volatile作用（面试常考）***

  - 内存可见性
  - 禁止指令重排序
  - **可以保证可加性，但是无法保证i++这种符合操作的原子性**。

2. synchronize（重量级锁）

   （1）3种形式：

   - 对于普通同步方法，锁是当前实例对象
   - 对于静态同步方法，锁是当前类的Class对象
   - 对于同步方法块，锁是Synchronize括号里配置的对象

   （2）实现原理

   ​	JVM基于进入和退出Monitor对象来实现方法同步和代码块的同步，但两者实现细节不一样。***代码块同步是使用monitorenter和monitorexit指令实现的***，而方法同步是使用两一种方式实现的。细节JVM规范没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

   ***synchronized用的锁是存在Java对象头里的***。

   ![Java对象头信息](https://github.com/Shengliannan/JDK_Learning/blob/master/img/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BF%A1%E6%81%AF.png?raw=true)

1. 轻量级锁
2. 偏向锁



## 线程

***现在操作系统调度的最小的单元是线程，也叫轻量级进程***。

1. 概念

一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局
部变量等属性，并且能够访问共享的内存变量。

2. 线程优先级

   可以通过setPriority(int)方法来设置优先级，默认优先级是5，优先级高的线程分配时间片的数据量要多于低优级的线程。***程序的正确性不能依赖线程的优先级高低***。

3. 线程的状态

   

## Java构造线程的方式

1. 继承Thread

2. 实现Runnable

3. 实现Callable接口

4. 应用场景

5. 实现Runnable和实现Callable的异同

   Callable又返回值，Runnable没有返回值。用Future类的对象来接收返回值。
6. submit和execute的异同
	submmit有返回值。
	

   

   

## Java并发包



## Java并发容器



## 原子操作类



## 锁
1. 避免死锁的方式
    （1） 避免一个线程同时获取多个锁
    （2） 避免一个线程在锁内同时占用多个资源，尽量保证锁只占用一个资源。
    （3）尝试使用***定时锁***，使用look.tryLock(timeout)来提待使用内部锁机制。
    （4）对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

2. 锁的状态

  锁一共有4中状态，级别从低到高依次是：

  - 无锁状态
  - 偏向锁状态
  - 轻量级锁状态
  - 重量级锁状态

  这几个状态随着竞争情况主键升级。***锁可以升级但不能降级***，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

  ![锁的优缺点对比](https://github.com/Shengliannan/JDK_Learning/blob/master/img/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94.png?raw=true)



3. 自旋锁

   因为线程阻塞后进入排队队列和唤醒都需要CPU从用户态转为核心态，尤其频繁的阻塞和唤醒对CPU来说是负荷很重的工作。同时统计发现，很多对象锁的锁定状态只会持续很短的一段时间，例如一个线程切换周期，这样的话在很短的时间内阻塞线程又很快唤醒线程显然不值得，所以引入了自旋锁概念。

   **所谓“自旋”**，就monitor并不把线程阻塞放入排队队列，而是去执行一个无意义的循环，循环结束后看看是否锁已释放并直接进行竞争上岗步骤，如果竞争不到继续自旋循环，循环过程中线程的状态一直处于running状态。明显自旋锁使得synchronized的对象锁方式在线程之间引入了不公平。但是这样可以保证大吞吐率和执行效率。

   不过虽然自旋锁方式省去了阻塞线程的时间和空间（队列的维护等）开销，但是长时间自旋也是很低效的。所以自旋的次数一般控制在一个范围内，例如10,50等，在超出这个范围后，线程就进入排队队列。

4. 原子操作的实现与原理

   Java中可以通过锁和循环CAS的方式来实现原子操作

   （1）使用循环CAS实现原子操作

   （2）CAS实现原子操作的三大问题

   - ABA问题
   - 循环时间开销大
   - 只能保证一个共享变量的原子操作

   （3）使用锁机制实现原子操作

5. CAS原理

6. 

## 线程池







## CPU层面的并发

