# JVM
***

## 一、前言

[OpenJdk](http://openjdk.java.net/)

jdk1.5 自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环、JUC

jdk1.7 提供新的G1收集器

虚拟机：HotSpot

查看JDK的版本和使用的虚拟机，以及GC策略

```java
C:\Program Files\Java\jdk1.8.0_191\bin>java -version
java version "1.8.0_191"      // 1.8
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)                                   //虚拟机：HotSpot JVM开启模式：Server
```





## 二、自动内存管理

### 2.1 Java内存区域与内存溢出异常

#### 2.1.1 JMM（Java内存模型）五大区域

Java虚拟机运行时数据区：***方法区、堆、虚拟机栈、本地方法栈、程序计数器***五个区域。

其中，方法区与堆是由所有线程共享的数据区；

虚拟机栈、本地方法栈、程序计数器是线程隔离的数据区（***线程私有***）。

- 程序计数器：

​	当前线程所执行的字节码的***行号指示器***，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

- Java虚拟机栈：

​	与程序计数器一样，Java虚拟机栈也是线程私有的，它的***生命周期与线程相同***。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。***每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈从入栈到出栈的过程。***

​	在Java虚拟机规范中，对于这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError异常**；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出**OutOfMemoryError**异常。

- 本地方法栈

​	本地方法栈与虚拟机栈所发挥的作用是非常的相似的，区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

- Java堆

​	JIT编译技术、逃逸分析技术（了解）

​	也被称为GC堆；现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为新生代（Eden空间、From Survivor空间、To Survivor空间）和老年代。如果在队中无法完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

***堆栈大小可通过参数控制***：

​	-Xmx -Xms

- 方法区（Non-Heap 非堆）

​	方法去与Java堆一样，是各个线程共享的内存区域，它用于存放已被虚拟机类加载的类信息、常量、静态变量、即时编译后的代码等数据。HotSpot虚拟机使用永久代来实现方法区。垃圾收集行为在这个区域比较少出现，当方法去无法满足内存分配的需求时，将抛出OutOfMemoryError异常。

​	运行时常量池

​       ***运行时常量池是方法取的一部分。***Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种***字面量和符号引用***，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征时具备动态性，Java语言并不要求常量一定只能在编译器产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员用的比较多的便是String类的***Intern()***方法。

​	既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

#### 2.1.2 OOM（OutOfMemoryError）内存溢出/内存泄露

- ***内存溢出*** out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；

- ***内存泄露*** memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

  memory leak会最终会导致out of memory！

> [参考](https://www.cnblogs.com/panxuejun/p/5883044.html)

1. Java堆溢出
- - 设置堆

  ```
  //虚拟机出现内存异常是Dump当前内存堆转储快照
  -XX:+HeapDumpOnOutOfMemoryError
  //设置堆最小内存20m
  -Xms20m
  //设置堆最大内存20m
  -Xmx20m
  ```

- 内存溢出，内存泄露问题排查

  

  内存映像分析工具

  Eclipse（Eclipse Memory Analyzer）

  Idea（JProfiler）

  > [参考](https://blog.csdn.net/wytocsdn/article/details/79258247)

  Java堆内存的OOM异常是实际应用中最常见的内存溢出异常情况。要解决这个区域的异常，一般的手段是首先通过映像分析工具对dump出来的堆转储快照进行分析。

  如果是内存泄露，查看GC Roots的引用链。

  如果是你此处溢出，检查虚拟机的对堆参数。

  

  用法简介：

  （1）. 配置IDEA，VM options：-XX:+HeapDumpOnOutOfMemoryError -Xms10m -Xmx10m
  （2）. 启动程序，出现OutOfMemoryError后会在根目录下生成一个java_pidXXXX.hprof文件
  （3）. 用JProfiler打开分析即可。

2. 虚拟机栈和本地方法栈溢出
    ***HotSpot虚拟机不区分虚拟机栈和本地方法栈***，栈容量只由于-Xss参数设定。

  关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：

  - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
  - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

3. 运行时常量池溢出

   ​	如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String对象的字符串，则返回池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

   ```java
   Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=1M; support was removed in 8.0
   Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=1M; support was removed in 8.0
   ```

   

## 三、垃圾收集器与内存分配策略

程序计数器、虚拟机栈、本地方法栈的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因此方法结束或线程技术时，内存自然也就回收了。而***Java堆***和***方法区***不同，这部分内存的分配和回收是动态的，垃圾收集器关注这一部分内存。

### 3.1 判断对象是否存活
1. 引用计数算法
    算法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1；计数器为0的对象就不可能再被使用。
    优点：实现简单，判定效率高
    缺点：无法解决对象之间的相互循环引用问题

2. ***根搜索算法***（重要，当前采用）

  在主流的商用程序语言中，都是使用根搜索算法判定对象是否存活。

  算法：通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

  ​	在Java语言里，可作为GC Roots的对象包括下面几种：

  - 虚拟机栈（栈帧中的本地变量表）中的引用的对象

  - 方法区中的类静态属性引用的对象。

  - 方法中的常量引用的对象

  - 本地方法栈中JNI（即一般说的Native方法）的引用的对象

    引用：（强度依次减弱）

    - 强引用

      只要强引用还在，垃圾收集器永远也不会回收被引用的对象。

    - 软引用

      对于软引用所关联着的对象，在***系统将要放生内存溢出异常之前***，将会把这些对象列进回收范围之中并进行二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。

    - 弱引用

      弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

    - 虚引用

      虚引用也成称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是希望在这个对象被收集器回收时收到一个系统通知。

    finalze()方法是对象逃脱死亡命运的最后一次机会。

### 3.2 垃圾回收算法
1.标记-清除法
	思想：算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
	缺点：效率不高，空间碎片多
2.复制算法
	思想：为了解决效率问题，将可用内存按容量划分为

### 3.3 GC查看
1. 打印gc日志
```
-XX:+PrintGCDetails
```
2. gc日志的含义
> [GC配置及日志解读](https://blog.csdn.net/qq_28165595/article/details/82431226)
>
> [可视化GC](https://gceasy.io/)

## 四、虚拟机性能监控与故障处理工具

## 五、调优案例分析与实战



CGLib





ThreadLocalMap