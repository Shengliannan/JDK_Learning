# # 第一部分 前言
***
## 一、some cake

[OpenJdk](http://openjdk.java.net/)

jdk1.5 自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环、JUC

jdk1.7 提供新的G1收集器

虚拟机：HotSpot

查看JDK的版本和使用的虚拟机，以及GC策略

```java
C:\Program Files\Java\jdk1.8.0_191\bin>java -version
java version "1.8.0_191"      // 1.8
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)                                   //虚拟机：HotSpot JVM开启模式：Server
```


# 第二部分  自动内存管理

## 二、 Java内存区域与内存溢出异常

###  2.1 JMM（Java内存模型）五大区域

Java虚拟机运行时数据区：***方法区、堆、虚拟机栈、本地方法栈、程序计数器***五个区域。

其中，方法区与堆是由所有线程共享的数据区；

虚拟机栈、本地方法栈、程序计数器是线程隔离的数据区（***线程私有***）。

- 程序计数器：

​	当前线程所执行的字节码的***行号指示器***，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

- Java虚拟机栈：

​	与程序计数器一样，Java虚拟机栈也是线程私有的，它的***生命周期与线程相同***。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。***每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈从入栈到出栈的过程。***

​	在Java虚拟机规范中，对于这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError异常**；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出**OutOfMemoryError**异常。

- 本地方法栈

​	本地方法栈与虚拟机栈所发挥的作用是非常的相似的，区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

- Java堆

​	JIT编译技术、逃逸分析技术（了解）

​	也被称为GC堆；现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为新生代（Eden空间、From Survivor空间、To Survivor空间）和老年代。如果在队中无法完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

***堆栈大小可通过参数控制***：

​	-Xmx -Xms

- 方法区（Non-Heap 非堆）

​	方法去与Java堆一样，是各个线程共享的内存区域，它用于存放已被虚拟机类加载的类信息、常量、静态变量、即时编译后的代码等数据。HotSpot虚拟机使用永久代来实现方法区。垃圾收集行为在这个区域比较少出现，当方法去无法满足内存分配的需求时，将抛出OutOfMemoryError异常。

​	运行时常量池

​       ***运行时常量池是方法取的一部分。***Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种***字面量和符号引用***，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征时具备动态性，Java语言并不要求常量一定只能在编译器产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员用的比较多的便是String类的***Intern()***方法。

​	既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

### 2.2 OOM（OutOfMemoryError）内存溢出/内存泄露

- ***内存溢出*** out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；

- ***内存泄露*** memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

  memory leak会最终会导致out of memory！

> [参考](https://www.cnblogs.com/panxuejun/p/5883044.html)

1. Java堆溢出
- 设置堆

  ```
  //虚拟机出现内存异常是Dump当前内存堆转储快照
  -XX:+HeapDumpOnOutOfMemoryError
  //设置堆最小内存20m
  -Xms20m
  //设置堆最大内存20m
  -Xmx20m
  ```

- 内存溢出，内存泄露问题排查

  

  内存映像分析工具

  Eclipse（Eclipse Memory Analyzer）

  Idea（JProfiler）

  > [参考](https://blog.csdn.net/wytocsdn/article/details/79258247)

  Java堆内存的OOM异常是实际应用中最常见的内存溢出异常情况。要解决这个区域的异常，一般的手段是首先通过映像分析工具对dump出来的堆转储快照进行分析。

  如果是内存泄露，查看GC Roots的引用链。

  如果是你此处溢出，检查虚拟机的对堆参数。

  

  用法简介：

  （1）. 配置IDEA，VM options：-XX:+HeapDumpOnOutOfMemoryError -Xms10m -Xmx10m
  （2）. 启动程序，出现OutOfMemoryError后会在根目录下生成一个java_pidXXXX.hprof文件
  （3）. 用JProfiler打开分析即可。

2. 虚拟机栈和本地方法栈溢出
    ***HotSpot虚拟机不区分虚拟机栈和本地方法栈***，栈容量只由于-Xss参数设定。

  关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：

  - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
  - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

3. 运行时常量池溢出

   ​	如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String对象的字符串，则返回池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

   ```java
   Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=1M; support was removed in 8.0
   Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=1M; support was removed in 8.0
   ```

   

## 三、垃圾收集器与内存分配策略

程序计数器、虚拟机栈、本地方法栈的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因此方法结束或线程技术时，内存自然也就回收了。而***Java堆***和***方法区***不同，这部分内存的分配和回收是动态的，垃圾收集器关注这一部分内存。

### 3.1 判断对象是否存活
1. 引用计数算法
    算法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1；计数器为0的对象就不可能再被使用。
    优点：实现简单，判定效率高
    缺点：无法解决对象之间的相互循环引用问题

2. ***根搜索算法***（重要，当前采用）

  在主流的商用程序语言中，都是使用根搜索算法判定对象是否存活。

  算法：通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

  ​	在Java语言里，可作为GC Roots的对象包括下面几种：

  - 虚拟机栈（栈帧中的本地变量表）中的引用的对象

  - 方法区中的类静态属性引用的对象。

  - 方法中的常量引用的对象

  - 本地方法栈中JNI（即一般说的Native方法）的引用的对象

    引用：（强度依次减弱）

    - 强引用

      只要强引用还在，垃圾收集器永远也不会回收被引用的对象。

    - 软引用

      对于软引用所关联着的对象，在***系统将要放生内存溢出异常之前***，将会把这些对象列进回收范围之中并进行二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。

    - 弱引用

      弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

    - 虚引用

      虚引用也成称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是希望在这个对象被收集器回收时收到一个系统通知。

    finalze()方法是对象逃脱死亡命运的最后一次机会。

### 3.2 垃圾回收算法

1. 标记-清除法
	思想：算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
	缺点：效率不高，空间碎片多
	
2. 复制算法
	思想：为了解决效率问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

​	缺点：内存缩小为原来的一半。

​	***Eden:From Survivor:To Survivor=8:1:1***

​	***<u>现代商业虚拟机都采用这种收集算法来回收新生代</u>***，并不需要按按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两个较小的Survivor的空间。当回收是，将Eden和Survivor中还存活着对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。

***HotSpot虚拟机默认Eden和Survivor的大小比例是8:1***，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被”浪费“的。当然，98%的对象可回收只是一般场景下的数据，***我们没有办法保证每次回收都有不多于10%的对象存活，当Survivor空间不够用，需要依赖其他内存（这里指老年代）进行<u>分配担保（Handle Promotion）</u>***。


3. 标记-整理算法

   思想：复制算法在对象存活率较高是就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有的对象都100%存活的极端情况，所以在老年代一般能能直接选用这种算法。

   根据老年代的特点，有人提出了另外一种“标记-整理”算发，***标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存***。

4. 分代收集算法
    思想：***当代商业虚拟机的垃圾收集都采用“分代收集”收集算法***，这种算法并没有什么新思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这种就可以根据各个年代的特点采用最适合的收集算法。

  ​	***新生代：复制算法***

  ​	***老年代：标记-整理算法***

### 3.3 垃圾收集器

​	如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。基于SunHotSpot虚拟机1.6版Update22，包含的收集器如下：

![HotSpot虚拟机1.6的来及收集器](https://raw.githubusercontent.com/Shengliannan/JDK_Learning/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.PNG)

#### 七种垃圾收集器概念&比较

- **Serial收集器（单线程，新生代）**

  Serial收集器是最基本、发展历史最悠久的收集器。是***单线程***的收集器。它在进行垃圾收集时，必须***暂停其他所有的工作线程***，直到它收集完成。

  Serial收集器依然是虚拟机运行在Client模式下默认新生代收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。

- **ParNew收集器（多线程、新生代）**

  ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程来及收集器之外，其余行为包括Serial收集器可用的所有控制参数，收集算法，Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。

- **Parallel Scavenge（并行回收）收集器（多线程、新生代、复制算法）**

  Parallel Scavenge收集器是一个***新生代收集器***，它也是使用***复制算法***的收集器。又是并行的多线程收集器。

  该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。
  $$
  吞吐量=\frac{运行用户代码时间}{运行用户代码时间+垃圾回收时间}
  $$
  停顿时间越短就越适合需要与用户交互的程序。

  自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

- **Serial Old收集器（单线程、老年代、标记-整理算法）**

  Serial Old是Serial收集器的老年代版本，它同样是一个单线程的收集器，使用***标记-整理算法***。这个***收集器的主要意义也是在于给Client模式下的虚拟机使用***。

- **Parallel Old收集器（多线程、老年代、标记-整理算法）**

  Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程“标记-整理算法）。

- **CMS收集器（多线程、老年代、标记-清除算法）**

  CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来比较好的体验。CMS收集器就非常符合这类应用的需求。

  CMS是基于“标记-清除”算法实现的。它的运行过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：

  （1）初始标记

  （2）并发标记

  （3）重新标记

  （4）并发清除

  其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。

  CMS收集器主要优点：并发收集、低停顿。

  缺点：无法处理浮动垃圾，收集结束后会产生大量空间碎片。

  **注：关于浮动垃圾的理解**

  > **重新标记（Remark）** 的作用在于：
  > 之前在并发标记时，因为是 GC 和用户程序是并发执行的，可能导致一部分已经标记为 **从 GC Roots 不可达** 的对象，因为用户程序的（并发）运行，**又可达** 了，**Remark** 的作用就是将这部分对象又标记为 **可达对象**。
  至于 “浮动垃圾”，因为 **CMS** 在 **并发标记** 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 **重新标记** 的作用只是修改之前 **并发标记** 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。

- G1收集器

  G1收集器的优势：

  （1）并行与并发

  （2）分代收集

  （3）空间整理（标记-整理算法，复制算法）

  （4）可预测的停顿

  使用G1收集器时，Java堆的内存布局是整个规划为多个大小相等独立区域（Region），***虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。***

  



如果两个收集器之间存在连线，就说明它们可以搭配使用。

client级别默认GC方式：串行GC（SerialGC）

server界别默认GC方式：并行回收GC（ParallelGC）

各种垃圾收集器（待整理）

Minor GC/Full GC

Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。新创建的对象都是用新生代分配的内存，***Eden空间不足时，触发Minor GC***，这是会把存活的对象转移进Survivor区。新生代采用复制算法，新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor区，并将对象年龄设为1,。对象子啊Survivor区中每熬过一个Minor GC，年龄就增加1，当它的年龄增加到一定程度（默认为15）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

Major GC/Full GC：老年代GC，老年代用于存放多次Minor GC之后依然存活的对象，当老年代满了，就会报OutOfMemory异常。***老年代采用标记算法进行回收***。



Minor GC ，Full GC 触发条件
Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法区空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

full gc 深入（待整理）


### 3.4 GC查看

1. 打印gc日志
```
-XX:+PrintGCDetails
```
2. gc日志的含义
> [GC配置及日志解读](https://blog.csdn.net/qq_28165595/article/details/82431226)
>
> [可视化GC](https://gceasy.io/)

## 四、虚拟机性能监控与故障处理工具

6个命令行和2个可视化的故障处理工具

- JDK命令行工具

1. jps：虚拟机进程状况工具
2. jstat：虚拟机统计信息监视工具
3. jinfo：Java配置信息工具
4. jmap：Java内存映像工具
5. jhat：虚拟机堆转储快照分析工具
6. jstack：Java堆栈跟踪工具

- JDK的可视化工具

1. JConsole：Java监视与管理控制台
2. VisualVM：多合一故障处理工具

## 五、调优案例分析与实战



CGLib





ThreadLocalMap

# 第三部分 虚拟机执行子系统

## 六、类文件结构

一、一些知识

1. 魔数与Class文件的版本

   每个Class文件的头4个字节称为魔术（Magic Number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的Class文件。

   ![Class文件版本号](https://github.com/Shengliannan/JDK_Learning/blob/master/img/Class%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7.PNG?raw=true)

## 七、虚拟机类加载机制

> [视频](<https://www.bilibili.com/video/av36188838/?p=13>)

1. 类加载机制概念：

​	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

​	与那些在编译时需要进行连接工作的语言不同，在Java语言里面，***类型的加载和连接过程都是在程序运行期间完成的***，这样会在类加载时稍微增加一些性能开销，但是却能为Java应用程序提供高度的灵活性，Java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现。这种组装应用程序的方式广泛应用于Java程序之中。

2. 类加载时机

   类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：

   - 加载（Loading）
   - 验证（Verification）
   - 准备（Preparation）
   - 解析（Resolution）
   - 初始化（Initialization）
   - 使用（Using）
   - 卸载（Unloading）

   七个阶段。

   其中，验证，准备，解析三个部分统称为链接。

3. 类加载器的层次结构

   - **引导类加载器(原生代码实现)**

     rt.jar

   - **扩展类加载器**

     ext.jar

   - **应用程序类加载器**

   - **自定义类加载器**

4. 双亲委派模型

   ​       某个特定的类加载器在接到加载类的请求时，首先加载任务委托给父类加载器，直到引导类加载器，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成加载任务时，才自己去加载。

   ​       双亲委托机制是为了保证Java核心库的类型安全。

   ​       ***类加载器除了用于加载类，也是安全的最基本的屏障。***

   **注：**

   ​	双亲委托机制是代理模式的一种。并不是所有的类加载器都从采用双亲委托机制。tomcat服务器加载器也使用代理模式，所不同的是它首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。

   

   